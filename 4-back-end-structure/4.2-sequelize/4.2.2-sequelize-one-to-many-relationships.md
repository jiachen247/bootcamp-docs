# 4.2.2: Sequelize One-to-Many Relationships

## Introduction

Sequelize makes querying for associated data in SQL relatively straightforward, but to leverage Sequelize we need to set up our migrations and models in specific ways. This module explores how to set up Sequelize to support one-to-many SQL relationships.

## Setup Packages and Folders, Configure DB

Set up Sequelize with a new Node application and configure the DB in the same way we did in [Module 4.2.1: Intro to Sequelize](4.2.1-intro-to-sequelize.md#setup-packages-and-folders). Update `config.js` to use a new DB name, `grocerystore_development` instead of `grocery_development` to distinguish the DBs from modules 4.2.1 and 4.2.2. Stop after creating the DB and follow the steps below to create a one-to-many SQL relationship with Sequelize. 

## Migrations: Create Categories and Items Tables

```text
npx sequelize-cli migration:generate --name create-items-table
```

Replace the contents of the generated file with the following table-creation code. Note the new `Categories` table and how the `Items` table references it via the `CategoryId` foreign key column. Sequelize knows `CategoryId` references the `id` column in the `Categories` table because of the `references` key in the `CategoryId` specification object.

#### Sample Migration File \(&lt;GENERATED\_DATE&gt;-create-item-table.js\)

```javascript
module.exports = {
  up: async (queryInterface, Sequelize) => {

    // Categories needs to be created first because Items references Categories
    await queryInterface.createTable('Categories', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      name: {
        type: Sequelize.STRING,
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });

    await queryInterface.createTable('Items', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      name: {
        type: Sequelize.STRING,
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      // By convention, foreign keys in Sequelize are in UpperCamelCase
      CategoryId: {
        allowNull: false,
        type: Sequelize.INTEGER,
        // This links the CategoryId column to the id column in the Categories table
        references: {
          model: "Categories",
          key: "id"
        }
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    // Items table needs to be dropped first because Items references Categories
    await queryInterface.dropTable('Items');
    await queryInterface.dropTable('Categories');
  },
};
```

Create the `Categories` and `Items` tables in our DB by running migrations.

```text
npx sequelize-cli db:migrate
```

Verify table creation in `psql`.

```text
psql -d grocerystore_development
```

## Models: Create Category and Item Models

#### models/category.mjs

```javascript
export default function categoryModel(sequelize, DataTypes) {
  return sequelize.define('Category', {
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER,
    },
    name: {
      type: DataTypes.STRING,
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
  });
}
```

#### models/item.mjs

```javascript
export default function itemModel(sequelize, DataTypes) {
  return sequelize.define('Item', {
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER,
    },
    name: {
      type: DataTypes.STRING,
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    categoryId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'Categories',
        key: 'id'
      },
    },
  });
}
```

#### models/index.mjs

```javascript
import { Sequelize } from 'sequelize';
import allConfig from '../config/config.js';

import itemModel from './item.mjs';
import categoryModel from './category.mjs';


const env = process.env.NODE_ENV || 'development';

const config = allConfig[env];

const db = {};

let sequelize = new Sequelize(config.database, config.username, config.password, config);

db.Item = itemModel(sequelize, Sequelize.DataTypes);
db.Category = categoryModel(sequelize, Sequelize.DataTypes);

db.Item.Category = db.Item.belongsTo(db.Category, {as:'category'});
db.Category.Items = db.Category.hasMany(db.Item, {foreignKey: 'categoryId'});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

export default db;
```

## Seed

```text
npx sequelize-cli seed:generate --name fake-data
```

#### &lt;GENERATED\_DATE&gt;-fake-data.js

```javascript
module.exports = {
  up: async (queryInterface) => {

    const categoriesList = [
      {
        name: 'fish',
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        name: 'fruits',
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        name: 'meat',
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];

    let categories = await queryInterface.bulkInsert("Categories", categoriesList, { returning: true });

    const items = [];
    for( let i=0;i<categories.length; i++){

      const category = categories[i];

      items.push({
        name: 'some item',
        categoryId:category.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      items.push({
        name: 'other item',
        categoryId:category.id,
        createdAt: new Date(),
        updatedAt: new Date()
      });

      items.push({
        name: 'iitemmm',
        categoryId:category.id,
        createdAt: new Date(),
        updatedAt: new Date()
      });
    }

    queryInterface.bulkInsert("Items", items);
  },

  down: async (queryInterface) => {
    await queryInterface.bulkDelete("Items", null, {});
    await queryInterface.bulkDelete("Categories", null, {});
  },
};
```

Run the migration

```javascript
npx sequelize-cli db:seed:all
```

#### index.mjs

```javascript
import db from './models/index.mjs';

db.Category
  .findOne({
    where: {
      name: process.argv[2]
    }
  })
  .then((returnedCategory) => {
    return db.Item.create(
      {
        name: process.argv[3],
        categoryId: returnedCategory.id
      },
      {
        returning: ['id']
      }
    )
  }).then(result => {

    console.log('success!!');
    console.log(result.id);

  }).catch(error => {

    console.log(error)
  });
```

Run it:

```text
node index.mjs fruit banana
```

Check the database:

```text
psql -d grocery_development
```

```text
SELECT * FROM items;
```

## Query Related Tables

This is where the magic actually happens.

When we have a `category` object, it will have a relation method based on the `hasMany` or `belongsTo` method we called on it. The method will be named after the other table.

On line 8 we call the `getItems` method to get all the items _**IN THAT CATEGORY**_.

```javascript
import db from './models/index.mjs';

db.Category.findOne({
  where: {
    name: [process.argv[2]]
  }
})
.then((category) => category.getItems())
.then((categoryItems) => console.log( categoryItems ))
.catch((error) => console.log(error));
```

Get the category given the item:

On line 8 we call the generated method called `getCategory`.

```javascript
import db from './models/index.mjs';

db.Item.findOne({
  where: {
    name: [process.argv[2]]
  }
})
.then((item) => item.getCategory())
.then((itemCategory) => console.log( itemCategory ))
.catch((error) => console.log(error));
```

## Exercise

Repeat the above code. 

