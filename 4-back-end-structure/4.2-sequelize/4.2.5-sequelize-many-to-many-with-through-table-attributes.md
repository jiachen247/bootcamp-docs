# 4.2.5: Sequelize Many-to-Many with "Through Table" Attributes

## Introduction

In [Module 3.4.5: Non-FK Relationship Data in Join Table](../../3-back-end-application/3.4-sql-language/3.4.5-non-fk-relationship-data-in-join-table.md) we added a `measurement` attribute to the join table between recipes and ingredients tables. In this module we will see how to do this with Sequelize. Sequelize refers to the join table as the "through table", due to the Sequelize `through` syntax to specify the name of the join table. The Sequelize docs on how to do this are [here](https://sequelize.org/master/manual/advanced-many-to-many.html).

## Setup Packages and Folders, Configure DB

Set up Sequelize with a new Node application and configure the DB in the same way we did in [Module 4.2.1: Intro to Sequelize](4.2.1-intro-to-sequelize.md#setup-packages-and-folders). Update `config.js` to use a new DB name, `carts_development` to distinguish the DB from other modules. Stop after creating the DB and follow the steps below to create a many-to-many SQL relationship with through table attributes with Sequelize.

## Migrations

```text
npx sequelize-cli migration:generate --name create-tables
```

### Sample Migration File \(&lt;GENERATED\_DATE&gt;-create-item-table.js\)

```javascript
module.exports = {
  up: async (queryInterface, Sequelize) => {
    // Create Items and Categories tables before the table that references them
    await queryInterface.createTable('Categories', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      name: {
        type: Sequelize.STRING,
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });

    await queryInterface.createTable('Items', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      name: {
        type: Sequelize.STRING,
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });

    await queryInterface.createTable('ItemsCategories', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      CategoryId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Categories',
          key: 'id',
        },
      },
      ItemId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Items',
          key: 'id',
        },
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });

    await queryInterface.createTable('Carts', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });

    await queryInterface.createTable('CartsItems', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      quantity: {
        type: Sequelize.INTEGER,
      },
      CartId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Carts',
          key: 'id',
        },
      },
      ItemId: {
        type: Sequelize.INTEGER,
        references: {
          model: 'Items',
          key: 'id',
        },
      },
    });
  },

  down: async (queryInterface) => {
    // Drop tables with foreign key references first
    await Promise.all([
      queryInterface.dropTable('ItemsCategories'),
      queryInterface.dropTable('CartsItems'),
    ]);
    await Promise.all([
      queryInterface.dropTable('Items'),
      queryInterface.dropTable('Categories'),
      queryInterface.dropTable('Carts'),
    ]);
  },
};
```

Create the above tables in our DB by running migrations.

```text
npx sequelize-cli db:migrate
```

## Models

### models/category.mjs

```javascript
export default function categoryModel(sequelize, DataTypes) {
  return sequelize.define('Category', {
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER,
    },
    name: {
      type: DataTypes.STRING,
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
  });
}
```

### models/item.mjs

```javascript
export default function itemModel(sequelize, DataTypes) {
  return sequelize.define('Item', {
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER,
    },
    name: {
      type: DataTypes.STRING,
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
  });
}
```

### models/cart.mjs

```javascript
export default function cartModel(sequelize, DataTypes) {
  return sequelize.define('Cart', {
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER,
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
  });
}
```

### models/cartsItem.mjs

Note that our model name must be `CartsItem` \(not `CartItem`\) so that Sequelize can automatically infer the table name `CartsItems`. More on this behaviour [here](https://sequelize.org/master/manual/model-basics.html#:~:text=By%20default%2C%20when%20the%20table,that%20as%20the%20table%20name.).

```javascript
export default function cartsItemModel(sequelize, DataTypes) {
  return sequelize.define(
    'CartsItem',
    {
      quantity: {
        type: DataTypes.INTEGER,
      },
    },
    {
      // timestamps: false prevents Sequelize from adding
      // createdAt and updatedAt timestamp fields
      // https://sequelize.org/master/class/lib/model.js~Model.html#static-method-init
      timestamps: false,
    }
  );
}
```

### models/index.mjs

```javascript
import sequelizePackage from 'sequelize';
import allConfig from '../config/config.js';

import itemModel from './item.mjs';
import categoryModel from './category.mjs';
import cartModel from './cart.mjs';
import cartsItemModel from './cartsItem.mjs';

const { Sequelize } = sequelizePackage;
const env = process.env.NODE_ENV || 'development';
const config = allConfig[env];
const db = {};

const sequelize = new Sequelize(
  config.database,
  config.username,
  config.password,
  config
);

db.Item = itemModel(sequelize, Sequelize.DataTypes);
db.Category = categoryModel(sequelize, Sequelize.DataTypes);
db.Cart = cartModel(sequelize, Sequelize.DataTypes);
db.CartsItem = cartsItemModel(sequelize, Sequelize.DataTypes);

// in order for the many-to-many to work we must mention the join table here.
db.Item.belongsToMany(db.Category, { through: 'ItemsCategories' });
db.Category.belongsToMany(db.Item, { through: 'ItemsCategories' });

// Connect Item and Cart models.
// Note: It's possible to use a Sequelize model class (i.e. CartsItem)
// to connect the models Item and Cart instead of the table name (i.e. CartsItems).
db.Item.belongsToMany(db.Cart, { through: db.CartsItem });
db.Cart.belongsToMany(db.Item, { through: db.CartsItem });

db.sequelize = sequelize;
db.Sequelize = Sequelize;

export default db;
```

## Seeds

Seed migration files are a specific category of migration file used to generate seed data. This is helpful when creating DB copies for testing purposes and we need reproduce-able data in the DB.

Use `sequelize-cli` to generate a seed data migration file.

```text
npx sequelize-cli seed:generate --name fake-data
```

### Sample Seed Data Migration File \(&lt;GENERATED\_DATE&gt;-fake-data.js\)

```javascript
module.exports = {
  up: async (queryInterface) => {
    // Define category data
    const categoryData = [
      {
        name: 'fish',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'fruit',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'healthy',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'canned',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    // Bulk insert categories
    const [
      fishCategory,
      fruitCategory,
      healthyCategory,
      cannedCategory,
    ] = await queryInterface.bulkInsert('Categories', categoryData, {
      returning: true,
    });

    // Define item data
    const itemData = [
      {
        name: 'banana',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'tuna',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'peach',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    // Bulk insert items
    const [banana, tuna, peach] = await queryInterface.bulkInsert(
      'Items',
      itemData,
      { returning: true }
    );

    // Define item category data based on generated items and categories
    const itemCategoryData = [
      // banana is a fruit
      {
        ItemId: banana.id,
        CategoryId: fruitCategory.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      // banana is healthy
      {
        ItemId: banana.id,
        CategoryId: healthyCategory.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      // tuna is fish
      {
        ItemId: tuna.id,
        CategoryId: fishCategory.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      // tuna is canned
      {
        ItemId: tuna.id,
        CategoryId: cannedCategory.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      // peach is fruit
      {
        ItemId: peach.id,
        CategoryId: fruitCategory.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      // peach is canned
      {
        ItemId: peach.id,
        CategoryId: cannedCategory.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    // Bulk insert item categories
    await queryInterface.bulkInsert('ItemsCategories', itemCategoryData);

    // Define cart data, 2 carts
    const cartData = [
      {
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    // Bulk insert carts
    const [cart1, cart2] = await queryInterface.bulkInsert('Carts', cartData, {
      returning: true,
    });

    // Define cart item data, i.e. put items in cart
    const cartsItemData = [
      {
        quantity: 1,
        ItemId: peach.id,
        CartId: cart1.id,
      },
      {
        quantity: 2,
        ItemId: banana.id,
        CartId: cart1.id,
      },
      {
        quantity: 4,
        ItemId: peach.id,
        CartId: cart2.id,
      },
    ];

    // Bulk insert cart items
    await queryInterface.bulkInsert('CartsItems', cartsItemData);
  },

  down: async (queryInterface) => {
    // Delete rows from tables with foreign key references first
    await queryInterface.bulkDelete('ItemsCategories', null, {});
    await queryInterface.bulkDelete('CartsItems', null, {});
    await queryInterface.bulkDelete('Items', null, {});
    await queryInterface.bulkDelete('Categories', null, {});
    await queryInterface.bulkDelete('Carts', null, {});
  },
};
```

Run seed migrations.

```javascript
npx sequelize-cli db:seed:all
```

## Sequelize Eager Loading

In Modules [4.2.2](4.2.2-sequelize-one-to-many-relationships.md) and [4.2.4](4.2.4-sequelize-many-to-many.md) we learned how to access associated data via Sequelize getter and setter methods. Typically we would do this sequentially, e.g. retrieve an item, then use a getter method to get all of its categories. Sequelize provides a way called "eager loading" to retrieve this data all at once, which uses join queries under the hood. See more on eager loading syntax [here](https://sequelize.org/master/manual/advanced-many-to-many.html).

### get.mjs

This is a command-line Node script. Run using the `node` command on command line. User eager loading we can get the first category of the first item in the first cart on line 9 with a single `findAll` query. `include` gives us the ability to retrieve any set of associated models.

```javascript
import db from './models/index.mjs';

db.Cart.findAll({
  include: {
    model: db.Item,
    include: [db.Category],
  },
})
  .then((carts) => console.log(carts[0].Items[0].Categories[0].name))
  .catch((error) => console.log(error));
```

## Accessing Attributes From Through Table

To access attributes from through \(aka join\) tables we need to define one-to-many associations from the through table to each of its associated tables. In this module's example, we would need to define one-to-many relationships between the `CartsItems` table and the `Carts` and `Items` tables respectively. These associations will be defined in the models/index.mjs file. See [Sequelize docs](https://sequelize.org/master/manual/advanced-many-to-many.html) for details.

### models/index.mjs

Update models/index.mjs to the following. Note lines 38-41.

```javascript
import sequelizePackage from 'sequelize';
import allConfig from '../config/config.js';

import itemModel from './item.mjs';
import categoryModel from './category.mjs';
import cartModel from './cart.mjs';
import cartsItemModel from './cartsItem.mjs';

const { Sequelize } = sequelizePackage;
const env = process.env.NODE_ENV || 'development';
const config = allConfig[env];
const db = {};

const sequelize = new Sequelize(
  config.database,
  config.username,
  config.password,
  config
);

db.Item = itemModel(sequelize, Sequelize.DataTypes);
db.Category = categoryModel(sequelize, Sequelize.DataTypes);
db.Cart = cartModel(sequelize, Sequelize.DataTypes);
db.CartsItem = cartsItemModel(sequelize, Sequelize.DataTypes);

// in order for the many-to-many to work we must mention the join table here.
db.Item.belongsToMany(db.Category, { through: 'ItemsCategories' });
db.Category.belongsToMany(db.Item, { through: 'ItemsCategories' });

// Connect Item and Cart models.
// Note: It's possible to use a Sequelize model class (i.e. CartsItem)
// to connect the models Item and Cart instead of the table name (i.e. CartsItems).
db.Item.belongsToMany(db.Cart, { through: db.CartsItem });
db.Cart.belongsToMany(db.Item, { through: db.CartsItem });

// Define 1-M associations between CartsItems table and associated tables
// to access CartsItem attributes from Item and Cart instances
db.Item.hasMany(db.CartsItem);
db.CartsItem.belongsTo(db.Item);
db.Cart.hasMany(db.CartsItem);
db.CartsItem.belongsTo(db.Cart);

db.sequelize = sequelize;
db.Sequelize = Sequelize;

export default db;
```

### get.mjs

Now we can access cart items and their attributes from `Item` instances.

```javascript
import db from './models/index.mjs';

db.Cart.findAll({
  include: {
    model: db.Item,
    include: [db.Category, db.CartsItem],
  },
})
  .then((carts) => console.log(carts[0].Items[0].CartsItems[0].quantity))
  .catch((error) => console.log(error));
```

## Exercise

Replicate the above code and verify results.

