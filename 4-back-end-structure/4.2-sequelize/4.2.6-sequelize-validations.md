# 4.2.6: Sequelize Validations

## Introduction

Sequelize contains functionality so that we can easily specify what kinds of data we want to go in the database.

There are two levels of restrictions we can set, constraints and validations.

## Setup

#### Initialise Node App

```text
npm init -y
```

#### Install Sequelize NPM Packages

```text
npm install pg sequelize
npm install --save-dev sequelize-cli
```

#### Create Sequelize Folders

```text
mkdir config migrations models seeders
```

### Configure Database

#### config/config.js

```javascript
module.exports = {
  development: {
    username: '<YOUR_UNIX_USER_NAME>',
    password: null,
    // Use "_development" suffix to indicate DB is for development purposes
    database: 'validations_development',
    host: '127.0.0.1',
    dialect: 'postgres',
  },
};
```

#### Create Database Based on Config.

```text
npx sequelize-cli db:create
```

### Migrations: Create Categories and Items Tables

```text
npx sequelize-cli migration:generate --name create-table
```

Replace the contents of the generated file with the following table-creation code.

#### Sample Migration File \(&lt;GENERATED\_DATE&gt;-create-table.js\)

```javascript
module.exports = {
  up: async (queryInterface, Sequelize) => {
    // Categories needs to be created first because Items references Categories
    await queryInterface.createTable('Categories', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      name: {
        type: Sequelize.STRING,
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });

    await queryInterface.createTable('Items', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      name: {
        allowNull: false,
        type: Sequelize.STRING,
      },
      createdAt: {
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      // By convention, foreign keys in Sequelize are in UpperCamelCase
      CategoryId: {
        type: Sequelize.INTEGER,
        // This links the CategoryId column to the id column in the Categories table
        references: {
          model: 'Categories',
          key: 'id',
        },
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    // Items table needs to be dropped first because Items references Categories
    await queryInterface.dropTable('Items');
    await queryInterface.dropTable('Categories');
  },
};
```

Create the `Categories` and `Items` tables in our DB by running migrations.

```text
npx sequelize-cli db:migrate
```

Verify table creation in `psql`.

```text
psql -d validations_development
```

### Models: Create Category and Item Models

#### models/category.mjs

```javascript
export default function categoryModel(sequelize, DataTypes) {
  return sequelize.define('Category', {
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER,
    },
    name: {
      type: DataTypes.STRING,
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
  });
}
```

#### models/item.mjs

```javascript
export default function itemModel(sequelize, DataTypes) {
  return sequelize.define('Item', {
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER,
    },
    name: {
      type: DataTypes.STRING,
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    // There is no need to specify the CategoryId foreign key in our model
    // because we do not need to access the foreign key from our application.
    // Sequelize uses the foreign key under the hood to get associated records.
    // Sequelize by default looks for a foreign key called CategoryId because of
    // belongsTo and hasMany associations defined in models/index.mjs.
  });
}
```

#### models/index.mjs

```javascript
import sequelizePackage from 'sequelize';
import allConfig from '../config/config.js';

import itemModel from './item.mjs';
import categoryModel from './category.mjs';

const { Sequelize } = sequelizePackage;
const env = process.env.NODE_ENV || 'development';
const config = allConfig[env];
const db = {};

let sequelize = new Sequelize(
  config.database,
  config.username,
  config.password,
  config
);

db.Item = itemModel(sequelize, Sequelize.DataTypes);
db.Category = categoryModel(sequelize, Sequelize.DataTypes);

db.Item.belongsTo(db.Category);
db.Category.hasMany(db.Item);

db.sequelize = sequelize;
db.Sequelize = Sequelize;

export default db;
```

### Seed: Create Seed Data for DB

Use `sequelize-cli` to generate a seed data migration file.

```text
npx sequelize-cli seed:generate --name fake-data
```

#### Sample Seed Data Migration File \(&lt;GENERATED\_DATE&gt;-fake-data.js\)

The following seed data migration file creates 3 categories, and 3 items that reference each of those categories, i.e. 9 items total. All our added to the DB when the seed migration runs.

```javascript
module.exports = {
  up: async (queryInterface) => {
    const categoriesList = [
      {
        name: 'fish',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'fruit',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        name: 'meat',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    // Insert categories before items because items reference categories
    let categories = await queryInterface.bulkInsert(
      'Categories',
      categoriesList,
      { returning: true }
    );

    const items = [];
    for (let i = 0; i < categories.length; i++) {
      const category = categories[i];

      items.push({
        name: 'some item',
        createdAt: new Date(),
        updatedAt: new Date(),
        CategoryId: category.id,
      });

      items.push({
        name: 'other item',
        createdAt: new Date(),
        updatedAt: new Date(),
        CategoryId: category.id,
      });

      items.push({
        name: 'iitemmm',
        createdAt: new Date(),
        updatedAt: new Date(),
        CategoryId: category.id,
      });
    }

    await queryInterface.bulkInsert('Items', items);
  },

  down: async (queryInterface) => {
    // Delete item before category records because items reference categories
    await queryInterface.bulkDelete('Items', null, {});
    await queryInterface.bulkDelete('Categories', null, {});
  },
};
```

Run seed migrations.

```javascript
npx sequelize-cli db:seed:all
```

#### create.mjs

```javascript
import db from './models/index.mjs';

db.Category.findOne({
  where: {
    name: [process.argv[2]],
  },
})
  .then((category) => {

    return db.Item.create({
      name: process.argv[3],
      CategoryId:category.id
    })
  })
  .then((item) => {
    console.log(item)
  })
  .catch((error) => {
    console.log(error)
  });
```

## Constraints

Constraints are settings we make when we create the database table. Sequelize will let us know when we violate one of these constraints.

### Allow Null

We have already been telling the database not to allow null values.

Let's make a change to the database so that we don't allow null \(empty\) for the item name, on line 9.

#### &lt;GENERATED\_DATE&gt;-create-table.js

```javascript
await queryInterface.createTable('Items', {
  id: {
    allowNull: false,
    autoIncrement: true,
    primaryKey: true,
    type: Sequelize.INTEGER,
  },
  name: {
    allowNull: false,
    type: Sequelize.STRING,
  },
  createdAt: {
    allowNull: false,
    type: Sequelize.DATE,
  },
  updatedAt: {
    allowNull: false,
    type: Sequelize.DATE,
  },
});
```

When we attempt to violate the constraint we get an error:

```javascript
node create.mjs fish
```

### Error Detection

If we want to write logic for this error, we need to import the error so we can put it in a conditional.

#### create.mjs

```javascript
import db from './models/index.mjs';

import pkg from 'sequelize';
const {DatabaseError} = pkg;


db.Category.findOne({
  where: {
    name: [process.argv[2]],
  },
})
  .then((category) => {

    return db.Item.create({
      name: process.argv[3],
      CategoryId:category.id
    })
  })
  .then((item) => {
    console.log(item)
  })
  .catch((error) => {

    if (error instanceof DatabaseError ){

      console.log('SORRY ITS A DATABSE ERROR');
      console.log(error)
    }else{
      console.log(error)
    }
  });
```

### Other Constraint Types

We can write similar constraints and logic for: uniqueness, foreign keys, etc. See more about Sequelize constraints here: [https://sequelize.org/master/manual/validations-and-constraints.html](https://sequelize.org/master/manual/validations-and-constraints.html)

## Validations

In the model we can specify what kind of data we want to allow into the database.

If we want to validate the presence of a field \(in JavaScript\) rather than send a query to the database, we can add the same code to the model file on line 11.

#### models/item.mjs

```javascript
export default function itemModel(sequelize, DataTypes) {
  return sequelize.define('Item', {
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER,
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    // There is no need to specify the CategoryId foreign key in our model
    // because we do not need to access the foreign key from our application.
    // Sequelize uses the foreign key under the hood to get associated records.
    // Sequelize by default looks for a foreign key called CategoryId because of
    // belongsTo and hasMany associations defined in models/index.mjs.
  });
}
```

### Error Detection

If we want to write logic for this error, we need to import the error so we can put it in a conditional.

#### create.mjs

```javascript
import db from './models/index.mjs';

import pkg from 'sequelize';
const {ValidationError} = pkg;


db.Category.findOne({
  where: {
    name: [process.argv[2]],
  },
})
  .then((category) => {

    return db.Item.create({
      name: process.argv[3],
      CategoryId:category.id
    })
  })
  .then((item) => {
    console.log(item)
  })
  .catch((error) => {

    if (error instanceof ValidationError ){
      console.log('SORRY VALIDATION ERROR!');

      console.log(error)
    }else{
      console.log(error)
    }
  });
```

### Other Validations

Here is an example with more validations on the model:

#### models/item.mjs

```javascript
export default function itemModel(sequelize, DataTypes) {
  return sequelize.define('Item', {
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER,
    },
    name: {
      type: DataTypes.STRING,
      unique: true,
      validate: {
        isAlpha: true,            // will only allow letters
        len: [3,23],
      }
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE,
    },
    // There is no need to specify the CategoryId foreign key in our model
    // because we do not need to access the foreign key from our application.
    // Sequelize uses the foreign key under the hood to get associated records.
    // Sequelize by default looks for a foreign key called CategoryId because of
    // belongsTo and hasMany associations defined in models/index.mjs.
  });
}
```

#### create.mjs

```javascript
import db from './models/index.mjs';

import pkg from 'sequelize';
const {UniqueConstraintError, ValidationError, DatabaseError} = pkg;


db.Category.findOne({
  where: {
    name: [process.argv[2]],
  },
})
  .then((category) => {

    return db.Item.create({
      name: process.argv[3],
      CategoryId:category.id
    })
  })
  .then((item) => {
    console.log(item)
  })
  .catch((error) => {

    if (error instanceof UniqueConstraintError ){

      console.log('SORRY UNIQUE ERROR');
      console.log(error)
    }else if (error instanceof ValidationError ){
      console.log('SORRY VALIDATION ERROR');

      console.log(error)
      console.log("THIS IS WHAT HAPPENED:");
      console.log(error.errors[0].message);

    }else if (error instanceof DatabaseError ){
      console.log('SORRY DB ERROR');

      console.log(error)
    }
    else{
      console.log(error)
    }
  });
```

Copy the code and try the following commands:

```javascript
node create.mjs fish some-item
```

```javascript
node create.mjs fish
```

```javascript
node create.mjs fish a
```

```javascript
node create.mjs fish ababababababababababababababababababababababababababababababababababababababababababa
```

## Error Handling in Express.js

Note that the structure of the validation data in the error is made such that it would be used to pass back to the user:

```javascript
errors: [
  ValidationErrorItem {
    message: 'Validation len on name failed',
    type: 'Validation error',
    path: 'name',
    value: 'h',
    origin: 'FUNCTION',
    instance: [Item],
    validatorKey: 'len',
    validatorName: 'len',
    validatorArgs: [Array],
    original: [Error]
  }
]
```

Note line 32 and 33 in the `create.mjs`above. This message would be displayed in the form to the user.

{% hint style="warning" %}
Note that normally we would not use `DatabaseError` to catch a null constraint like we did in the first example. This is because `DatabaseError` is also used when a SQL query fails, for example when you misspell the name of a table in the model file. It also does not give you the english formatted error text as in the example below. Always add the validation to the model as well in the case of null.
{% endhint %}

## Documentation

See the validation documentation here: [https://sequelize.org/master/manual/validations-and-constraints.html](https://sequelize.org/master/manual/validations-and-constraints.html)

See a full list of possible Sequelize errors here: [https://sequelize.readthedocs.io/en/latest/api/errors/](https://sequelize.readthedocs.io/en/latest/api/errors/)

