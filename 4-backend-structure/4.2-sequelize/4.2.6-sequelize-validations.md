# 4.2.6: Sequelize Validations

## Introduction

Sequelize allows us to police what data gets stored in the database with database constraints and model validations.

## Setup Packages and Folders, Configure DB

Set up Sequelize with a new Node application and configure the DB in the same way we did in [Module 4.2.1: Intro to Sequelize](4.2.1-intro-to-sequelize.md#setup-packages-and-folders). Update `config.js` to use a new DB name, `validations_development` to distinguish the DB from other modules. Stop after creating the DB and follow the steps below to create a one-to-many SQL relationship with through table attributes with Sequelize.

### Migrations: Create Categories and Items Tables

```text
npx sequelize migration:generate --name create-categories-items-tables
```

Replace the contents of the generated file with the following table-creation code.

#### Sample Migration File \(&lt;GENERATED\_DATE&gt;-create-categories-items-tables.js\)

```javascript
module.exports = {
  up: async (queryInterface, Sequelize) => {
    // Categories needs to be created first because Items references Categories
    await queryInterface.createTable('categories', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      name: {
        type: Sequelize.STRING,
      },
      created_at: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });

    await queryInterface.createTable('items', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      name: {
        allowNull: false,
        type: Sequelize.STRING,
      },
      category_id: {
        type: Sequelize.INTEGER,
        references: {
          model: 'categories',
          key: 'id',
        },
      },
      created_at: {
        type: Sequelize.DATE,
      },
      updated_at: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });
  },

  down: async (queryInterface, Sequelize) => {
    // items table needs to be dropped first because items references categories
    await queryInterface.dropTable('items');
    await queryInterface.dropTable('categories');
  },
};
```

Create the `categories` and `items` tables in our DB by running migrations.

```text
npx sequelize db:migrate
```

Verify table creation in `psql`.

```text
psql -d validations_development
```

### Models: Create Category and Item Models

#### models/category.mjs

```javascript
export default function initCategoryModel(sequelize, DataTypes) {
  return sequelize.define(
    'category',
    {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: DataTypes.INTEGER,
      },
      name: {
        type: DataTypes.STRING,
      },
      createdAt: {
        allowNull: false,
        type: DataTypes.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: DataTypes.DATE,
      },
    },
    {
      // The underscored option makes Sequelize reference snake_case names in the DB.
      underscored: true,
    }
  );
}
```

#### models/item.mjs

```javascript
export default function initItemModel(sequelize, DataTypes) {
  return sequelize.define(
    'item',
    {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: DataTypes.INTEGER,
      },
      name: {
        type: DataTypes.STRING,
      },
      categoryId: {
        type: DataTypes.INTEGER,
        references: {
          model: 'categories',
          key: 'id',
        },
      },
      createdAt: {
        allowNull: false,
        type: DataTypes.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: DataTypes.DATE,
      },
    },
    {
      // The underscored option makes Sequelize reference snake_case names in the DB.
      underscored: true,
    }
  );
};
```

#### models/index.mjs

```javascript
import sequelizePackage from 'sequelize';
import allConfig from '../config/config.js';

import initItemModel from './item.mjs';
import initCategoryModel from './category.mjs';

const { Sequelize } = sequelizePackage;
const env = process.env.NODE_ENV || 'development';
const config = allConfig[env];
const db = {};

let sequelize = new Sequelize(
  config.database,
  config.username,
  config.password,
  config
);

db.Item = initItemModel(sequelize, Sequelize.DataTypes);
db.Category = initCategoryModel(sequelize, Sequelize.DataTypes);

db.Item.belongsTo(db.Category);
db.Category.hasMany(db.Item);

db.sequelize = sequelize;
db.Sequelize = Sequelize;

export default db;
```

### Seed: Create Seed Data for DB

Use `sequelize-cli` to generate a seed data migration file.

```text
npx sequelize seed:generate --name seed-data
```

#### Sample Seed Data Migration File \(&lt;GENERATED\_DATE&gt;-seed-data.js\)

The following seed data migration file creates 3 categories, and 3 items that reference each of those categories, i.e. 9 items total. All our added to the DB when the seed migration runs.

```javascript
module.exports = {
  up: async (queryInterface) => {
    const categoriesList = [
      {
        name: 'fish',
        created_at: new Date(),
        updated_at: new Date(),
      },
      {
        name: 'fruit',
        created_at: new Date(),
        updated_at: new Date(),
      },
      {
        name: 'meat',
        created_at: new Date(),
        updated_at: new Date(),
      },
    ];

    // Insert categories before items because items reference categories
    let categories = await queryInterface.bulkInsert(
      'categories',
      categoriesList,
      { returning: true }
    );

    const items = [];
    for (let i = 0; i < categories.length; i++) {
      const category = categories[i];

      items.push({
        name: 'some item',
        category_id: category.id,
        created_at: new Date(),
        updated_at: new Date(),
      });

      items.push({
        name: 'other item',
        category_id: category.id,
        created_at: new Date(),
        updated_at: new Date(),
      });

      items.push({
        name: 'iitemmm',
        category_id: category.id,
        created_at: new Date(),
        updated_at: new Date(),
      });
    }

    await queryInterface.bulkInsert('items', items);
  },

  down: async (queryInterface) => {
    // Delete item before category records because items reference categories
    await queryInterface.bulkDelete('items', null, {});
    await queryInterface.bulkDelete('categories', null, {});
  },
};
```

Run seed migrations.

```javascript
npx sequelize db:seed:all
```

## Database Constraints

Database constraints are set in migrations. Sequelize will let us know when we violate one of these constraints.

### Allow Null

In the migration we ran above, we told our DB to not allow null values for the `name` column of the `items` table. Let's try to violate this constraint.

#### &lt;GENERATED\_DATE&gt;-create-categories-items-table.js

```javascript
await queryInterface.createTable('items', {
  id: {
    allowNull: false,
    autoIncrement: true,
    primaryKey: true,
    type: Sequelize.INTEGER,
  },
  name: {
    // In our migration above, we set allowNull to false for the name column.
    allowNull: false,
    type: Sequelize.STRING,
  },
  created_at: {
    allowNull: false,
    type: Sequelize.DATE,
  },
  updated_at: {
    allowNull: false,
    type: Sequelize.DATE,
  },
});
```

#### violateDbConstraint.mjs

Create a `violateDbConstraint.mjs` script to try to violate our DB constraint.

```javascript
import db from './models/index.mjs';

const violateDbConstraint = async () => {
  try {
    const category = await db.Category.findOne({
      where: {
        name: [process.argv[2]],
      },
    });
    const associatedItem = await db.Item.create({
      name: process.argv[3],
      categoryId: category.id,
    });
    console.log(associatedItem);
  } catch (error) {
    console.log(error);
  }
}

violateDbConstraint();
```

#### Sample Command

Only specify 1 argument to `create.mjs` so `process.argv[3]` will be undefined.

```javascript
node create.mjs fish
```

#### Sample Output

When we attempt to violate the constraint we get the following error with debugging output below it.

```text
DatabaseError [SequelizeDatabaseError]: null value in column "name" of relation "items" violates not-null constraint
```

### Error Detection

If we want to catch this DB constraint error in our program and write error-handling logic for the DB constraint error separate from other error-handling logic, we need to import the `DatabaseError` class from Sequelize. Update `violateDbConstraint.mjs` to perform different logic for database errors.

#### violateDbConstraint.mjs

```javascript
import sequelizePackage from 'sequelize';
import db from './models/index.mjs';

const { DatabaseError } = sequelizePackage;

const violateDbConstraint = async () => {
  try {
    const category = await db.Category.findOne({
      where: {
        name: [process.argv[2]],
      },
    });
    const associatedItem = await db.Item.create({
      name: process.argv[3],
      categoryId: category.id,
    });
    console.log(associatedItem);
  } catch (error) {
    if (error instanceof DatabaseError) {
      console.log('This is a database error!');
      console.log(error);
    } else {
      console.log(error);
    }
  }
}

violateDbConstraint();
```

{% hint style="warning" %}
Note that normally we would not use `DatabaseError` to catch a null constraint like we did in the first example. This is because `DatabaseError` is also used when a SQL query fails, for example when you misspell the name of a table in the model file. It also does not give you the English-formatted error text as in the validation error example below. Always add validation to models whenever possible, for example in the case of null-checking.
{% endhint %}

{% hint style="info" %}
More info on the differences between `typeof` and `instanceof` operators [here](https://stackoverflow.com/questions/899574/what-is-the-difference-between-typeof-and-instanceof-and-when-should-one-be-used).
{% endhint %}

.

### Other Constraints

We can write similar DB constraints and logic for properties such as uniqueness and foreign key validity. Read more on Sequelize DB constraints here: [https://sequelize.org/master/manual/validations-and-constraints.html](https://sequelize.org/master/manual/validations-and-constraints.html).

## Model Validations

We can specify constraints on our models as well, such that we can detect constraint violations before making DB queries. Constraints are called "validations" in the model context. 

### Allow Null

For example, if we wanted to validate the presence of a field before running a DB query, we could add a non-null validation to the model. 

#### models/item.mjs

Update our `item.mjs` model to add an `allowNull` validation for the `name` attribute.

```javascript
export default function itemModel(sequelize, DataTypes) {
  return sequelize.define(
    'item',
    {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: DataTypes.INTEGER,
      },
      name: {
        // This validation is new.
        allowNull: false,
        type: DataTypes.STRING,
      },
      createdAt: {
        allowNull: false,
        type: DataTypes.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: DataTypes.DATE,
      },
    },
    {
      // The underscored option makes Sequelize reference snake_case names in the DB.
      underscored: true,
    }
  );
}
```

### Error Detection

Let's violate the model violation we just added on the `name` attribute. Let's create a `violateModelValidation.mjs` script that performs special logic for validation errors by importing the `ValidationError` class from Sequelize.

#### violateModelValidation.mjs

```javascript
import sequelizePackage from 'sequelize';
import db from './models/index.mjs';

const { ValidationError } = sequelizePackage;

const violateModelValidation = async () => {
  try {
    const category = await db.Category.findOne({
      where: {
        name: [process.argv[2]],
      },
    });
    const associatedItem = await db.Item.create({
      name: process.argv[3],
      categoryId: category.id,
    });
    console.log(associatedItem);
  } catch (error) {
    if (error instanceof ValidationError) {
      console.log('This is a validation error!');
      console.log(error);
    } else {
      console.log(error);
    }
  }
}

violateModelValidation();
```

### Other Validations

Let's add more validations to our model and violate them.

#### models/item.mjs

Notice the validations for the `name` attribute.

```javascript
export default function itemModel(sequelize, DataTypes) {
  return sequelize.define(
    'item',
    {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: DataTypes.INTEGER,
      },
      name: {
        // The following custom validations are new.
        validate: {
          // isAlpha allows only alphanumeric characters.
          isAlpha: true, 
          // This only allows strings of length 3 to 23.
          len: [3, 23],
        },
        type: DataTypes.STRING,
      },
      categoryId: {
        type: DataTypes.INTEGER,
        references: {
          model: 'categories',
          key: 'id',
        },
      },
      createdAt: {
        allowNull: false,
        type: DataTypes.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: DataTypes.DATE,
      },
    },
    {
      // The underscored option makes Sequelize reference snake_case names in the DB.
      underscored: true,
    }
  );
}
```

#### violateModelValidation.mjs

Update `violateModelValidation.mjs` to include the following error-handling logic.

```javascript
import sequelizePackage from 'sequelize';
import db from './models/index.mjs';

const {
  ValidationError,
  DatabaseError,
} = sequelizePackage;

db.Category.findOne({
  where: {
    name: [process.argv[2]],
  },
})
  .then((category) => {
    return db.Item.create({
      name: process.argv[3],
      categoryId: category.id,
    });
  })
  .then((item) => {
    console.log(item);
  })
  .catch((error) => {
    if (error instanceof ValidationError) {
      console.log('This is a validation error!');
      console.log(error);
      console.log('The following is the first error message:');
      console.log(error.errors[0].message);
    } else if (error instanceof DatabaseError) {
      console.log('This is a database error!');
      console.log(error);
    } else {
      console.log(error);
    }
  });
```

#### Sample Commands

Try the following sample commands to observe what error messages show when we violate the constraints and validations in different ways.

```javascript
node violateModelValidation.mjs fish some-item
```

```javascript
node violateModelValidation.mjs fish
```

```javascript
node violateModelValidation.mjs fish a
```

```javascript
node violateModelValidation.mjs fish ababababababababababababababababababababababababababababababababababababababababababa
```

### Validation Error Objects

Validation errors are structured so we can handle such errors gracefully. We could show the user what happened by parsing the data in the `ValidationErrorItem` object and sending an error message to the client via a response. This message could be displayed in the form with invalid input client-side.

#### Sample Errors Object

```javascript
errors: [
  ValidationErrorItem {
    message: 'Validation len on name failed',
    type: 'Validation error',
    path: 'name',
    value: 'h',
    origin: 'FUNCTION',
    instance: [Item],
    validatorKey: 'len',
    validatorName: 'len',
    validatorArgs: [Array],
    original: [Error]
  }
]
```

## Further Reading

1. See the validation documentation here: [https://sequelize.org/master/manual/validations-and-constraints.html](https://sequelize.org/master/manual/validations-and-constraints.html)
2. See a full list of possible Sequelize errors here: [https://sequelize.readthedocs.io/en/latest/api/errors/](https://sequelize.readthedocs.io/en/latest/api/errors/)

