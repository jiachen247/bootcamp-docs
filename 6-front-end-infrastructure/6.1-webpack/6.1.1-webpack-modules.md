# 6.1.1: Webpack Modules

## Introduction

Pre-compiling front-end code with Webpack affords secondary benefits, including ability to use `import` statements. `import` gives us a few benefits.

1. Import gives us finer-grained control about how our code is run. Previously, the order of HTML `script` tags determined the order of the JavaScript code execution.
2. Each imported module is a separate namespace from others- the files do not interact unless explicitly programmed to.
3. In [Module 6.1.2: Webpack with NPM](6.1.2-webpack-with-npm.md) we will learn how to use 3rd-party NPM libraries which can be imported using `import`.

Webpack claims its main feature is "module bundling". Read more about this functionality here: [https://webpack.js.org/concepts/](https://webpack.js.org/concepts/).

## Webpack Import Order of Events

Webpack will transform our source JS files connected by import statements into a single output file that contains all dependencies that the imports reference.

![](../../.gitbook/assets/webpack-import-2.jpg)

1. The `webpack` command is run.
2. Webpack reads an `import` statement in the source `script.js` file.
3. Based on the `import`, Webpack retrieves all dependency code. If the imported module depends on other modules, Webpack retrieves those modules too.
4. Webpack writes the compiled file into the `dist` directory.
5. The server is started with `node index.js`. A request is made to the server. The server responds with the compiled JS file in `dist`.

## Webpack Import Example

Create a directory and install Webpack

```text
mkdir import-webpack-demo
cd import-webpack-demo
npm init -y
npm install webpack webpack-cli --save-dev
```

Create some files to work with:

```text
mkdir src dist
touch src/script.js
touch src/case.js
touch dist/index.html
```

#### src/case.js

```javascript
export function camel(input) {
  return input.split(' ').join('_');
}

export function scream(input) {
  return input.toUpperCase();
}
```

#### src/script.js

```javascript
import { camel } from './case.js';

const component = () => {
  // make a container
  const div = document.createElement('div');

  // display element
  const span = document.createElement('span');

  // input
  const input = document.createElement('input');

  // on change, display in the span
  input.addEventListener('change', function () {
    // use the imported code
    span.innerText = camel(input.value);
  });

  div.appendChild(input);
  div.appendChild(span);

  return div;
};

document.body.appendChild(component());
```

#### dist/index.html

```markup
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Getting Started</title>
  </head>
  <body>
    <script src="script.js"></script>
  </body>
</html>
```

### Webpack configuration:

#### webpack.config.js

```javascript
const path = require('path');

module.exports = {
  entry: './src/script.js',
  output: {
    filename: 'script.js',
    path: path.resolve(__dirname, 'dist'),
  },
};
```

## Run Webpack

```text
npx webpack --mode=production
```

### `dist/script.js`

Look in the generated script file. The imported JavaScript will be in this single file.

To see a formatted version of this output file, install the [Beautify plugin for VSCode.](https://marketplace.visualstudio.com/items?itemName=HookyQR.beautify)

### Production

The `production` option on the command gives a default set of configurations of which transformations are happening.

See a full list here: [https://webpack.js.org/configuration/mode/](https://webpack.js.org/configuration/mode/) here: [https://webpack.js.org/configuration/mode/\#mode-production](https://webpack.js.org/configuration/mode/#mode-production) and here: [https://webpack.js.org/plugins/module-concatenation-plugin/](https://webpack.js.org/plugins/module-concatenation-plugin/)

{% hint style="warning" %}
Note that is quite rare to configure Webpack from scratch. Here we used the normal production configuration like would be used in the workflow described in the illustration above. Don't worry about knowing much about the default transformations.
{% endhint %}

Notice how Webpack chose to format the final version of the code. Notice that the second function in `case.js` is not in the final version of the file.

Make some changes to the code to see how it affects the code when you run Webpack again.

