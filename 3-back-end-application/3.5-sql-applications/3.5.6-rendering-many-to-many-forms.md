# 3.5.6: Rendering Many-to-Many Forms

## Introduction

Similar to one-to-many forms, when creating forms for many-to-many relationships in the DB we want to allow the user to choose from options without worrying about DB IDs.

In this example we'll construct a form that creates the set of rows in the relationship table that puts the recipe in a set of categories.

Unlike with the one-to-many example it's not even possible to create a single form input for the categories. We could have typed multiple numbers into the input \(e.g., 5,2,3,6,9\), but they would  have to be processed into an array in the route.

```javascript
<form action="/recipe/1/categories" method="POST">
    <input type="text" name="category_id">
    <input type="submit" value="Submit">
</form>
```

## Check Boxes

![](../../.gitbook/assets/screen-shot-2020-11-24-at-4.29.59-pm.png)

In the case of a many-to-many relationship with a join table, we can represent creating this relationship with check boxes.

A checkbox is the UI design element that represents zero or many selections of a category of thing.

We'll create a special route to put a given recipe into categories. It gets the same information as the previous example.

#### index.js

```javascript
app.get('/recipes/:id/categories/add', (request, response) => {

  pool.query('select * from categories', (error, result)=>{

    const data = {
      categories : result.rows
    };

    response.render('categories', data);

  });

})
```

#### categories-form.ejs

```markup
<form action="/recipie/<%= recipieId %>/categories" method="POST">
    <% categories.forEach((category) => { %>
        <label><%= category.name %></label>
        <input type="checkbox" id="sdfsdf" name="category_ids" value="<%= category.id %>">
    <% }); %>
    <input type="text" name="label">
    <input type="submit" value="Submit">
</form>
```

Notice that this is going to render a checkbox for each existing category, every checkbox has the same input `name` attribute.

If all three categories are checked, the request will look like this:

![](../../.gitbook/assets/screen-shot-2020-11-24-at-3.46.44-pm.png)

Notice that the keys, or properties of the data being sent are all the same.

Express.js is smart enough to put these values into an array.

```javascript
app.post('/recipie/:id/categories', (request, response) => {
  console.log( request.body.category_ids ); // will be an array of numbers
  response.send('works');
});
```

 We need to be able to take these values and put them into the database:

```javascript
app.post('/recipe/:id/categories', (request, response) => {

  console.log( request.body.category_ids );

  // get the recipe id url param
  const recipeId = request.params.id;

  const queryString = 'INSERT INTO recipe_categories (recipe_id, category_id) VALUES ($1, $2)';

  // for each category we have in the request, make an insert query
  request.body.category_ids.forEach((category_id, index) => {

    // construct the set of values we are inserting
    const values = [recipeId, category_id];

    pool.query(queryString, values, (error, result) => {
    
      // query is done
      console.log(result);
    });
  });

  response.send('done');
});
```

Note there is a SQL syntax to insert multiple values into the same table, but pg does not parameterize these kinds of queries. See more [here](https://github.com/brianc/node-postgres/issues/957). 

## Asynchronous Set of Callbacks

One problem here is that we want to send the response to this query **when all of the inserts are done.** On line 19, the callback we are running is when **only one of the queries is done**.

We need some logic that tells us that `category_id.length` number of queries has finished.

Starting at line 11 above:

```javascript
let queryDoneCounter = 0;

// for each category we have in the request, make an insert query
request.body.category_ids.forEach((category_id, index) => {

  // construct the set of values we are inserting
  const values = [recipeId, category_id];

  pool.query(queryString, values, (error, result) => {
  
    // query is done
    console.log(result);
    
    // increment the counter, another query is done
    queryDoneCounter +=1;
    
    // check to see if all the queries are done
    if( queryDoneCounter === request.body.category_ids.length ){
      
      // TODO: check if any of the queries had errors.
      
      // all the queries are done, send a response.
      response.send('done!');
    }
    
  });
});
```

## Associating Categories On Recipe Creation

We probably just want to create the category-recipe relationship when the recipe gets created, although this doesn't preclude the functionality of being able to associate the recipe and the category after the recipe has been created. It depends on what you decide you want in your app.

If we decide we want to make the association on recipe creation, we'll want to add the above database code into the recipe creation code:

```javascript
app.post('/recipe', (request, response) => {

  const recipeValues = [request.body.label]; 

  const recipeInsertQuery = 'INSERT INTO recipes (label) VALUES ($1) RETURNING *';
  
  pool.query(recipeInsertQuery, recipeValues, (recipeError, recipeResult) => {
    
    if( recipeError ){
      response.status(501).send('error!');
      return;
    }
    
    const recipeId = recipeResult.rows[0].id;
  
    const categoryInsertQuery = 'INSERT INTO recipe_categories (recipe_id, category_id) VALUES ($1, $2)';
  
    let queryDoneCounter = 0;
  
    // for each category we have in the request, make an insert query
    request.body.category_ids.forEach((category_id, index) => {
    
      // construct the set of values we are inserting
      const categoryValues = [recipeId, category_id];
    
      pool.query(categoryInsertQuery, categoryValues, (categoryError, categoryResult) => {
        // query is done
        console.log(categoryResult.rows);
        
        queryDoneCounter +=1;
        
        if( queryDoneCounter === request.body.category_ids.length ){
          response.send('done!');
        }
        
      });
    });
  });
});
```

### RETURNING \*

In some sets of nested queries we need the result of an `INSERT` in order to proceed with the next query. Here on line 5 we are using `RETURNING *` at the end of our `INSERT` query so that we get back the primary key that was created.

