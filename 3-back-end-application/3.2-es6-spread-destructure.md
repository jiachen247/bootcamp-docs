# 3.2: ES6 Spread / Destructure

ES6 provides some nice syntax features to work with arrays, objects and function arguments and return values.

We'll look at some useful common cases. For a more comprehensive overview, check out[ this page.](https://www.digitalocean.com/community/tutorials/understanding-destructuring-rest-parameters-and-spread-syntax-in-js)

There are two overall types of syntax we'll look at: destructure and spread.

Note that most of these syntaxes work similarly for arrays and objects.

## Destructure

Assign array or object properties.

### Get named variables out of an object

```javascript
const user = { name: 'kai' };
const { name } = user; // creates a variable called name
console.log(name); // outputs 'kai'
```

### Get named variables out of an array

Assign and name variables _according to their position_ in an array.

```javascript
const row = ['X', 'O', 'X'];
const [left, center, right] = row;
console.log(center); // outputs 'O';
```

### Return multiple values from a function

If you return an object from a function you can get named variables out of the return value with destructuring. \(Note this is the same ES syntax as the above example, but simply used in a function\).

```javascript
const conversions = (temperatureInFahrenheit) => {
    let temperatureInCelcius = // ...
    let temperatureInKelvin = // ...

    return {
        kelvin : temperatureInKelvin,
        celcius : tempreatureInCelcius
    }
};

const {kelvin, celcius} = conversions(20);
console.log( kelvin );
console.log( celcius );
```

## import

Import uses destructure syntax to create values out of the imported modules.

```javascript
export function kilometersToMiles(kilometers) {
  // ...
}

export function celciusToFahrenheit(temperatureCelcius) {
  // ...
}

export function kilogramsToPounds(kilograms) {
  // ...
}
```

**index.js**

```javascript
import {
  kilometersToMiles,
  celciusToFahrenheit,
  kilgramsToPounds,
} from './addition.js';

console.log(kilometersToMiles(3));
console.log(celciusToFahrenheit(3));
console.log(kilogramsToPounds(3));
```

## Spread

Take a group of values and spread them into new values.

### Get around reference vs. value problems \(copy an array\)

Assigning one array to a new variable doesn't make a copy of the values.

```javascript
const temperatures = [23, 12, 45];
const temperaturesCopy = temperatures; // this is not a new array inside the var
temperatureCopy.pop(); // thius affects temperatures var as well
```

Using the spread operator makes a copy of the array values.

```javascript
const temperatures = [23, 12, 45];
const temperaturesCopy = [...temperatures]; // makes a copy of the array
temperatureCopy.pop(); // this DOES NOT affect temperatures var
```

Note this works for objects as well.

### Combine arrays together

```javascript
const names = ['susan chan', 'garfield'];
const names2 = ['alex', 'chee kean'];
const combinedArray = [...names, ...names2]; // has all four elements inside
```

### Combine objects together

```javascript
const userData = { name: 'kai' };
const userData2 = { height: 6 };
const combinedUserData = { ...userData, ...userData2 }; // has both keys inside
```

### Get an array of function arguments

This is called rest parameters.

```javascript
const add = (...numbers) => {
  let total = 0;
  for (let i = 0; i < numbers.length; i += 1) {
    total += numbers[i];
  }
  return total;
};
```

Works so that no matter how many numbers are passed to add, it will still work.

```javascript
add(2, 2, 2); // will return 6
add(1, 1, 1, 1, 1, 1); // will also return 6
```

