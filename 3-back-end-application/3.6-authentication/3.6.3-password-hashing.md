# 3.6.3: Password Hashing

It is bad security practice to save a plain text password in the database.

Instead we'll implement a system where we can verify that when the user logs in that they are using the same password as when they registered by keeping a proxy value in the database _that is not their original actual password_.

We will do this with a **cryptographic hash algorithm**.

[According to wikipedia](https://en.wikipedia.org/wiki/Cryptographic_hash_function) a cryptographic hash is: 

> ... a mathematical algorithm that maps data of arbitrary size to a bit array of a fixed size

A hash function takes a string and irreversibly translates it into another string.

The most important aspect of this transformation is that for a given string, \(e.g., "hello"\), the same value will always be output, e.g., "xyz123". I can rely on the fact that when I put "hello" into the function, "xyz123" will always be the output.

We can keep the original input a secret because of the other features of a hash function:

#### The output is always the same length, no matter what size the input is.

For the specific algorithm we'll use SHA512, which outputs a message that is always 512 bits in size. \(We can format this output in different ways, but we'll be outputting a hexadecimal number and saving it as a string\).

If the input is 4 bits or 4 GB, the algorithm will always output a 512 bit number.

#### A small change in the input creates a big change in the output.

Hash string "a":

```javascript
1f40fc92da241694750979ee6cf582f2d5d7d28e18335de05abc54d0560e0f5302860c652bf08d560252aa5e74210546f369fbbbce8c12cfc7957b2652fe9a75
```

Hash string "A":

```javascript
21b4f4bd9e64ed355c3eb676a28ebedaf6d8f17bdc365995b319097153044080516bd083bfcce66121a3072646994c8430cc382b8dc543e84880183bf856cff5
```

Note that the two outputs look completely different.

#### You can't tell what the input is by looking at the output.

The hash obfuscates the original input, and it is mathematically difficult to take the output value and recreate the input value.

#### The chances of two inputs creating the same output are sufficiently small.

As mentioned above, a very large input can be represented by the 512 bit output. In this sense the hash function loses information. We're encapsulating a possibly very big input into 512 bits. It is therefore possible that two input values will result in the same output value.

The creators of these functions have mathematically verified the probability of two values producing the same output, and that probability for any good hash function is small. [See more here.](https://stackoverflow.com/questions/4014090/is-it-safe-to-ignore-the-possibility-of-sha-collisions-in-practice)

### jsSHA

```javascript
npm install jsssha
```

```javascript
import jsSHA from "jssha";

const shaObj = new jsSHA("SHA-512", "TEXT", { encoding: "UTF8" });
shaObj.update("Text to hash.");
const hash = shaObj.getHash("HEX");

console.log("hashed text");
console.log(hash);
```

### User Auth

We'll use this hash function in two places.

#### When the user registers.

When the user registers instead of permanently recording their password in the database we will create a hash of the password and store that instead and discard the password itself.

```javascript
app.post('/signup', (request, response) => {
  console.log('request came in');
  
  const shaObj = new jsSHA("SHA-512", "TEXT", { encoding: "UTF8" });
  
  // input the value from the request
  shaObj.update(request.body.password);
  
  // get the value out
  const hashedPassword = shaObj.getHash("HEX");
    
  const values = [request.body.email, hashedPassword];

  pool.query('INSERT INTO users (email, password) VALUES ($1, $2)', values, (error, result) => {
    // ...
```

#### When the user logs in.

When the user logs in we'll hash the incoming value.

If the hashed value is the same as the value in the database, it's the same value as the one the user originally entered, so we have verified this user.

Starting on line 22 we added the login password hashing code.

```javascript
app.post('/login', (request, response) => {
  console.log('request came in');

  const values = [request.body.email];

  pool.query('SELECT * from users WHERE email=$1', values, (error, result) => {
    if (error) {
      console.log('Error executing query', error.stack);
      response.status(503).send(result.rows);
      return;
    }

    if (result.rows.length === 0) {
      // we didnt find a user with that email.
      // the error for password and user are the same. don't tell the user which error they got for security reasons, otherwise people can guess if a person is a user of a given service.
      response.status(403).send('sorry!');
      return;
    }

    const user = result.rows[0];

    const shaObj = new jsSHA("SHA-512", "TEXT", { encoding: "UTF8" });
    
    // input the value from the request
    shaObj.update(request.body.password);
    
    // get the value out
    const hashedPassword = shaObj.getHash("HEX");

    if (user.password === hashedPassword) {
      response.cookie('loggedIn', true);
      response.send('logged in!');
    } else {
      // password didn't match
      // the error for password and user are the same. don't tell the user which error they got for security reasons, otherwise people can guess if a person is a user of a given service.
      response.status(403).send("sorry!");
    }
  });
});
```

