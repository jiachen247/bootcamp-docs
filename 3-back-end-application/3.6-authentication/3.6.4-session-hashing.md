# 3.6.4: Session Hashing

## Introduction

We need to make our original implementation of cookies more secure, because anyone can open the Chrome Dev Tools Application tab and type in a cookie value.

![](../../.gitbook/assets/screen-shot-2020-11-17-at-8.30.38-pm.png)

We'll use the idea of a "salt", which we are going to use as a system-wide secret word. If we combine it with information we set in a separate cookie, we can create a hashed value in the cookie instead of the string "loggedIn" and have that value be verifiable when our server checks if the cookie is authentic.

## Generating the Hashed Cookie Value

After successful login, we generate a hashed cookie value using a combination of user ID and salt, and send that value to the client in a response cookie.

```javascript
import jsSha from 'jssha';

// the SALT is a constant value.
// In practice we would not want to store this "secret value" in plain text in our code.
// We will learn methods later in SWE1 to obfuscate this value in our code.
const SALT = 'bananas are delicious';

// ... route declaration, user record retrieval, and password hashing here

// if hashed password doesn't match, return
if (user.password !== hashedPassword) {
  response.send('login failed!');
  return;
}

// create new SHA object
const shaObj = new jsSha('SHA-512', 'TEXT', { encoding: 'UTF8' });
// create an unhashed cookie string based on user ID and salt
const unhashedCookieString = `${user.id}-${SALT}`;
// generate a hashed cookie string using SHA object
const hashedCookieString = shaObj.getHash(unhashedCookieString);
// set the loggedInHash and userId cookies in the response
response.cookie('loggedInHash', hashedCookieString);
response.cookie('userId', user.id);
// end the request-response cycle
response.send('logged in!');
```

## Verifying the Hashed Cookie Value

When the client visits pages that require authentication, we regenerate the hashed cookie value and verify it against the request cookie value. If the values match, the client is authenticated.

```javascript
import jsSha from 'jssha';

// the SALT is a constant value.
// In practice we would not want to store this "secret value" in plain text in our code.
// We will learn methods later in SWE1 to obfuscate this value in our code.
const SALT = 'bananas are delicious';

// ... route declaration here

// extract loggedInHash and userId from request cookies
const { loggedInHash, userId } = request.cookie;
// create new SHA object
const shaObj = new jsSha('SHA-512', 'TEXT', { encoding: 'UTF8' });
// reconstruct the hashed cookie string
const unhashedCookieString = `${userId}-${SALT}`;
const hashedCookieString = shaObj.getHash(unhashedCookieString);

// verify if the generated hashed cookie string matches the request cookie value.
// if hashed value doesn't match, return 403.
if (hashedCookieString !== request.cookie.loggedInHash) {
  response.status(403).send('please login!');
  return;
}

// hashed values match and cookie is authentic.
response.send('logged in!');
```

## Environment Variables

In a real life scenario, we would not put some secret security-sensitive string like a salt in the JavaScript file. In general it's considered bad practice to keep sensitive secrets inside a codebase.

We would use an environment variable, which is a unix concept that deals with values set on individual computers \(the individual computer being the "environment"\). Our code can then read that environment variable when the JavaScript file loads.

Depending on the scale of the organization, there could be an entire set of infrastructure dedicated to managing these secret environment variables. Although it is already more secure if the value is just a file that sits on your computer.

Set an environment variable by typing in the command line:

```javascript
export MYVAL='hello'
```

Get a hold of this value in JavaScript:

#### index.js 

```javascript
const myVal = process.env['MYVAL'];
```

#### Naming

Environment variables are always scream case.

#### Setting

Using export will only work for the life of that terminal window. If you want to have this value around permanently you can copy the entire export line into `.bashrc` or `.zshrc`.

See more about environment variables [here.](https://www.cyberciti.biz/faq/set-environment-variable-unix/)

There are also libraries especially made for managing these values on your local computer per project. See more [here.](https://www.twilio.com/blog/working-with-environment-variables-in-node-js-html)

