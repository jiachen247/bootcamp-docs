# 3.6.4: Session Hashing

## Introduction

We need to make our original implementation of cookies more secure, because anyone can open the Chrome Dev ToolsÂ Application tab and type in a cookie value.

![](../../.gitbook/assets/screen-shot-2020-11-17-at-8.30.38-pm.png)

We'll use the idea of a "salt", which we are going to use as a system-wide secret word. If we combine it with information we set in a separate cookie, we can create a hashed value in the cookie instead of the string "loggedIn" and have that value be verifiable when our server checks if the cookie is authentic. 

## Generating the Hashed Cookie Value

```javascript
import jsSHA from "jssha";
const SALT = "bananas are delicious";

// ...

if( user.password === request.body.password ){

  const shaObj = new jsSHA("SHA-512", "TEXT TO HASH", { encoding: "UTF8" });
  
  const cookieHashString = `${user.id}-${SALT}`;
  
  const cookie = shaObj.getHash(cookieHashString);
 
  response.cookie('loggedInHash', cookie);
  response.cookie('userId', user.id);

  response.send('logged in!');
}else{

  // password didn't match
  response.send("sorry!");
}    

```

## Verifying the Hashed Cookie Value

```javascript
import jsSHA from "jssha";
const SALT = "bananas are delicious";

// ...

const loggedInHash = request.cookie.loggedInHash;
const userId = request.cookie.userId;

const shaObj = new jsSHA("SHA-512", "TEXT TO HASH", { encoding: "UTF8" });

// reconstruct the hashed value from above    
const cookieHashString = `${userId}-${SALT}`;

// compare them. if it isnt the same value, the cookie is not authentic
if( cookieHashString === request.cookie.loggedInHash ){

  response.send('logged in!');
}else{

  // password didn't match
  response.status(403).send("sorry!");
}    
```

