# 3.6.4: Session Hashing

## Introduction

We need to make our original implementation of cookies more secure, because anyone can open the Chrome Dev Tools Application tab and type in a cookie value.

![](../../.gitbook/assets/screen-shot-2020-11-17-at-8.30.38-pm.png)

We'll use the idea of a "salt", which we are going to use as a system-wide secret word. If we combine it with information we set in a separate cookie, we can create a hashed value in the cookie instead of the string "loggedIn" and have that value be verifiable when our server checks if the cookie is authentic.

## Generating the Hashed Cookie Value

After successful login, we generate a hashed cookie value using a combination of user ID and salt, and send that value to the client in a response cookie.

```javascript
import jsSha from 'jssha';

// the SALT is a constant value.
// In practice we would not want to store this "secret value" in plain text in our code.
// We will learn methods later in SWE1 to obfuscate this value in our code.
const SALT = 'bananas are delicious';

// ... route declaration, user record retrieval, and password hashing here

// if hashed password doesn't match, return
if (user.password !== hashedPassword) {
  response.send('login failed!');
  return;
}

// create new SHA object
const shaObj = new jsSha('SHA-512', 'TEXT', { encoding: 'UTF8' });
// create an unhashed cookie string based on user ID and salt
const unhashedCookieString = `${user.id}-${SALT}`;
// generate a hashed cookie string using SHA object
const hashedCookieString = shaObj.getHash(unhashedCookieString);
// set the loggedInHash and userId cookies in the response
response.cookie('loggedInHash', hashedCookieString);
response.cookie('userId', user.id);
// end the request-response cycle
response.send('logged in!');
```

## Verifying the Hashed Cookie Value

When the client visits pages that require authentication, we regenerate the hashed cookie value and verify it against the request cookie value. If the values match, the client is authenticated.

```javascript
import jsSha from 'jssha';

// the SALT is a constant value.
// In practice we would not want to store this "secret value" in plain text in our code.
// We will learn methods later in SWE1 to obfuscate this value in our code.
const SALT = 'bananas are delicious';

// ... route declaration here

// extract loggedInHash and userId from request cookies
const { loggedInHash, userId } = request.cookie;
// create new SHA object
const shaObj = new jsSha('SHA-512', 'TEXT', { encoding: 'UTF8' });
// reconstruct the hashed cookie string
const unhashedCookieString = `${userId}-${SALT}`;
const hashedCookieString = shaObj.getHash(unhashedCookieString);

// verify if the generated hashed cookie string matches the request cookie value.
// if hashed value doesn't match, return 403.
if (hashedCookieString !== request.cookie.loggedInHash) {
  response.status(403).send('please login!');
  return;
}

// hashed values match and cookie is authentic.
response.send('logged in!');
```

