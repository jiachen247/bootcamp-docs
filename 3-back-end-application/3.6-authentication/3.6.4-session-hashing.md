# 3.6.4: Session Hashing

We need to make our original implementation of the cookie value more secure.

Anyone can simply open up the Application tab of the Chrome Browser tools and type in the cookie value.

![](../../.gitbook/assets/screen-shot-2020-11-17-at-8.30.38-pm.png)

We'll use the idea of a salt, which we are going to use as a system wide secret word. If we combine it with information we set in a separate cookie, we can create a hashed value in the cookie instead of loggedIn and have that value be verifiable when we want to check if the cookie is authentic. 

#### Making the cookie value:

```javascript
import jsSHA from "jssha";
const SALT = "bananas are delicious";

// ...

if( user.password === request.body.password ){

  const shaObj = new jsSHA("SHA-512", "TEXT TO HASH", { encoding: "UTF8" });
  
  const cookieHashString = `${user.id}-${SALT}`;
  
  const cookie = shaObj.getHash(cookieHashString);
 
  response.cookie('loggedInHash', cookie);
  response.cookie('userId', user.id);

  response.send('logged in!');
}else{

  // password didn't match
  response.send("sorry!");
}    

```

#### Verifying the cookie value:

```javascript
import jsSHA from "jssha";
const SALT = "bananas are delicious";

// ...

const loggedInHash = request.cookie.loggedInHash;
const userId = request.cookie.userId;

const shaObj = new jsSHA("SHA-512", "TEXT TO HASH", { encoding: "UTF8" });

// reconstruct the hashed value from above    
const cookieHashString = `${userId}-${SALT}`;

// compare them. if it isnt the same value, the cookie is not authentic
if( cookieHashString === request.cookie.loggedInHash ){

  response.send('logged in!');
}else{

  // password didn't match
  response.status(403).send("sorry!");
}    
```

