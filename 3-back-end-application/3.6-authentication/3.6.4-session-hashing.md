# 3.6.4: Session Hashing

## Introduction

We need to make our original implementation of cookies more secure, because anyone can open the Chrome Dev Tools Application tab and type in a cookie value.

![](../../.gitbook/assets/screen-shot-2020-11-17-at-8.30.38-pm.png)

We'll use the idea of a "salt", which we are going to use as a system-wide secret word. If we combine it with information we set in a separate cookie, we can create a hashed value in the cookie instead of the string "loggedIn" and have that value be verifiable when our server checks if the cookie is authentic.

## Generating the Hashed Cookie Value

After successful login, we generate a hashed cookie value using a combination of user ID and salt, and send that value to the client in a response cookie.

```javascript
import jsSha from 'jssha';

// the SALT is a constant value.
// In practice we would not want to store this "secret value" in plain text in our code.
// We will learn methods later in SWE1 to obfuscate this value in our code.
const SALT = 'bananas are delicious';

// ... route declaration, user record retrieval, and password hashing here

// if hashed password doesn't match, return
if (user.password !== hashedPassword) {
  response.send('login failed!');
  return;
}

// create new SHA object
const shaObj = new jsSha('SHA-512', 'TEXT', { encoding: 'UTF8' });
// create an unhashed cookie string based on user ID and salt
const unhashedCookieString = `${user.id}-${SALT}`;
// generate a hashed cookie string using SHA object
const hashedCookieString = shaObj.getHash(unhashedCookieString);
// set the loggedInHash and userId cookies in the response
response.cookie('loggedInHash', hashedCookieString);
response.cookie('userId', user.id);
// end the request-response cycle
response.send('logged in!');
```

## Verifying the Hashed Cookie Value

When the client visits pages that require authentication, we regenerate the hashed cookie value and verify it against the request cookie value. If the values match, the client is authenticated.

```javascript
import jsSha from 'jssha';

// the SALT is a constant value.
// In practice we would not want to store this "secret value" in plain text in our code.
// We will learn methods later in SWE1 to obfuscate this value in our code.
const SALT = 'bananas are delicious';

// ... route declaration here

// extract loggedInHash and userId from request cookies
const { loggedInHash, userId } = request.cookie;
// create new SHA object
const shaObj = new jsSha('SHA-512', 'TEXT', { encoding: 'UTF8' });
// reconstruct the hashed cookie string
const unhashedCookieString = `${userId}-${SALT}`;
const hashedCookieString = shaObj.getHash(unhashedCookieString);

// verify if the generated hashed cookie string matches the request cookie value.
// if hashed value doesn't match, return 403.
if (hashedCookieString !== request.cookie.loggedInHash) {
  response.status(403).send('please login!');
  return;
}

// hashed values match and cookie is authentic.
response.send('logged in!');
```

## Environment Variables

In practice we would never put secret strings like salts in JavaScript. In general it's considered bad practice to keep secrets inside a codebase, because anyone that accesses the codebase will access the secret.

The alternative is to use environment variables, which are a Unix concept that sets values on individual computers, where the computer is the "environment". Our code can then read those environment variables when our code files load.

Depending on the scale of the organization, there could be an entire set of infrastructure dedicated to managing these secret environment variables. [Here](https://geekflare.com/secret-management-software/) are some common implementations. In a basic implementation, our system is already more secure if the value is in an environment or file on our computers that is not stored in the codebase.

Set an environment variable with the `export` command on the command line. This sets the environment variable for the current terminal session. This means that if we were to close and reopen our terminal, or open a terminal window somewhere else, the environment would be reset. Env vars are named in SCREAM\_CASE by convention.

```javascript
export MY_ENV_VAR='hello'
```

Get a hold of this value in JavaScript:

#### index.js 

```javascript
const myVal = process.env['MYVAL'];
```

#### Naming

Environment variables are always scream case.

#### Setting

Using export will only work for the life of that terminal window. If you want to have this value around permanently you can copy the entire export line into `.bashrc` or `.zshrc`.

See more about environment variables [here.](https://www.cyberciti.biz/faq/set-environment-variable-unix/)

There are also libraries especially made for managing these values on your local computer per project. See more [here.](https://www.twilio.com/blog/working-with-environment-variables-in-node-js-html)

