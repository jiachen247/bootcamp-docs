# 3.6.5: Custom Middleware for Authentication

## Introduction

Currently we construct auth logic separately for every route where we authenticate users. We'll refactor our app to authenticate users automatically on every request. We'll also be able to get the logged-in user from the database on every request.

## Middleware

Express.js middleware is a function or set of functions that can be configured to run before or after a request. We will use middleware to refactor our user authentication code to run before our routes. Read more on middleware [here](https://expressjs.com/en/guide/using-middleware.html).

### `app.use`

Like `app.get`, `app.use` sets a callback that will run when a request arrives. Unlike `app.get`, the `app.use` callback runs on every request, regardless of the URL path. Add the following code to your app before your routes:

```javascript
app.use((request, response, next) => {
  console.log('Every request:', request.path);
  next();
});
```

This code runs for requests to routes you have and requests that have no route. Try the path `/something-that-doesnt-exist`.

### `next`

`next` is a function that invokes the next middleware bound to `app`. `next` must be called if the current middleware does not end the request-response cycle, otherwise the request will hang. More on how to use `next` [here](https://expressjs.com/en/guide/writing-middleware.html).

```javascript
app.use((request, response, next) => {
  if (request.path == '/some-path') {
    response.status(404).send('sorry');
    return;
  }
  next();
});
```

## Cookie-Checking Middleware

Let's implement refactored cookie checking functionality that will check the incoming cookies for every request.

First we'll put the hashing code into it's own function:

```javascript
// remember to include the lib at the top of the file
import jsSha from 'jssha';

// initialize salt as a global constant
const SALT = process.env.SALT;

// ...

const getHash = (input) => {
  // create new SHA object
  const shaObj = new jsSha('SHA-512', 'TEXT', { encoding: 'UTF8' });

  // create an unhashed cookie string based on user ID and salt
  const unhashedString = `${input}-${SALT}`;

  // generate a hashed cookie string using SHA object
  shaObj.update(unhashedString);

  return shaObj.getHash('HEX');
};
```

### `app.use`

The way we'll let the route know whether or not the user has logged in or not is to set a new key in the `request` object called `isUserLoggedIn`. \(You can name it something less verbose\).

```javascript
app.use((request, response, next) => {
  // set the default value
  request.isUserLoggedIn = false;

  // check to see if the cookies you need exists
  if (request.cookies.loggedIn && request.cookies.userId) {
    // get the hased value that should be inside the cookie
    const hash = getHash(request.cookies.userId);

    // test the value of the cookie
    if (request.cookies.loggedIn === hash) {
      request.isUserLoggedIn = true;
    }
  }

  next();
});
```

### Route Logic

In the route we can look for the key and write logic for that particular thing.

![](../../.gitbook/assets/my-document-13-.jpg)

In this example we want to render the form to create a new recipe. A user is associated with a recipe by their `user_id`, therefore, a user must be logged in before they can fill out the form.

In real life we might redirect the user to another page if they are not allowed.

```javascript
app.get('/recipes', (request, response) => {
  if (request.isUserLoggedIn === false) {
    response.status(403).send('sorry');
    return;
  }

  // ...
});
```

## Selective Middleware

We don't always want to run the middleware for every single request to the server.

If we want to be selective about what middleware runs base on the route we can pass it as a callback to the route itself:

```javascript
app.get('/recipes', checkAuth, (request, response) => {
  if (request.isUserLoggedIn === false) {
    response.status(403).send('sorry');
    return;
  }

  // ...
});
```

We would simply need to create the `checkAuth` function. This is the just the entire callback in `app.use` above.

## Routes with User Data

In certain apps you want to know about which specific user is logged in for every request. \(Although you may also want to put relevant data into a cookie\).

We can add code to the middleware that queries the database on a request to get all the data about the user.

### `app.use`

After we've verified the hashed cookie we can query the database based on the user id in the cookie. When we find a user we can set a key in request like we did above and have access to the user's attributes when we run the route.

```javascript
import pg from 'pg';
const { Pool } = pg;

// ...

const pool = new Pool(pgConnectionConfigs);

// ...

app.use((request, response, next) => {
  // set the default value
  request.isUserLoggedIn = false;

  // check to see if the cookies you need exists
  if (request.cookies.loggedIn && request.cookie.userId) {
    // get the hased value that should be inside the cookie
    const hash = getHash(request.cookies.userId);

    // test the value of the cookie
    if (request.cookies.loggedIn === hash) {
      request.isUserLoggedIn = true;

      // look for this user in the database
      const values = [request.cookies.userId];

      // try to get the user
      pool.query('SELECT * FROM users WHERE id=$1', values, (error, result) => {
        if (error || result.rows.length < 1) {
          response.status(503).send('sorry!');
          return;
        }

        // set the user as a key in the request object so that it's accessible in the route
        request.user = result.rows[0];

        next();
      });

      // make sure we don't get down to the next() below
      return;
    }
  }

  next();
});
```

Note that on line 37 we are setting the whole user result into the request, normally we would not want to include the user's password data in any object we pass along.

