# 2.13.2: JSON File Storage Module - Passing Callbacks

## Introduction

Currently the logic that runs after a file is read into memory is hard-coded in `jsonFileStorage`, e.g. in the `add` function. This is not ideal because we would need to create a new function that repeats file reading and writing code for each type of file edit operation, like we did in [2.ICE.5: Reading and Writing to JSON](../2.ice-in-class-exercises/2.ice.5-json-cards.md#limitations-with-current-jsonfilestorage-module). A more elegant solution would be to pass custom edit operation logic into `jsonFileStorage` so that `jsonFileStorage` can continue to be generic, and we can re-use it across apps without repeating code.

## Temperature App

1. Let's build an app that records a list of temperatures in a JSON file and provides the average of recorded temperatures on-demand.
2. We'll upgrade `jsonFileStorage` such that our app can pass custom logic to it, and we can re-use the same `jsonFileStorage` code later for other apps.

### Database Format

The format of our JSON file `data.json` might look like the following.

```javascript
{
  "temperatures": [23, 32, 43, 12]
}
```

### List Temperatures

We could use our existing `read` function from `jsonFileStorage` to read temperatures from our DB.

```javascript
import { read } from 'jsonFileStorage.js';

// Print all temperatures in data.json
read('data.json');
```

### Get Average Temperature

There is no code in `jsonFileStorage` that allows us to retrieve data elegantly from our JSON DB and operate on it. If we were to write this code from scratch, it might look like the following.

#### index.js

```javascript
const handleFileRead = (readErr, jsonContentStr) => {
  if (readErr) {
    console.log('Reading error', readErr);
  }

  // Convert JSON content from string to object
  const jsonContentObj = JSON.parse(jsonContentStr);
  
  // Extract temperatures variable from JSON for readability
  const temperatures = jsonContentObj.temperatures;

  // Calculate average temperature
  let totalTemp = 0;
  for (let i = 0; i < temperatures.length; i += 1) {
    totalTemp += temperatures[i];
  }
  const avgTemp = totalTemp / temperatures.length;

  // Log average temperature
  console.log(avgTemp);
};

// Read JSON DB and operate on its data
readFile('data.json', 'utf-8', handleFileRead);
```

This is similar to the pattern we suggested in [2.ICE.5: Reading and Writing to JSON](../2.ice-in-class-exercises/2.ice.5-json-cards.md#limitations-with-current-jsonfilestorage-module), which is not ideal because it requires us to repeat boilerplate reading and potentially writing code. Let's see how we can modify `jsonFileStorage` to handle the boilerplate logic, while accepting custom logic from client applications.

## Passing Callbacks to `jsonFileStorage`

We could move `handleFileRead` into `index.js` and pass it as a parameter to `read`. The code would look like the following.

#### index.js

```javascript
import { read } from 'jsonFileStorage.js';

// The client application defines custom logic, while jsonFileStorage handles
// boilerplate reading and writing logic
const handleFileRead = (readErr, jsonContentStr) => {
  // Same code as above
};

read('data.json', handleFileRead);
```

#### jsonFileStorage.js

```javascript
import { readFile } from 'fs';

// The client application provides the handleFileRead callback.
// This increases customisability of the jsonFileStorage module.
export function read(filename, handleFileRead) {
  readFile(filename, 'utf-8', handleFileRead);
}
```

## Further Reducing Repeated Code

The above architecture is ok, but requires us to repeat logic like `JSON.parse` in every `handleFileRead` callback we write. Let's move the standard `JSON.parse` code into `jsonFileStorage` such that the callback we pass to `jsonFileStorage` only contains the custom logic and no boilerplate logic.

In order to accomplish that, we can not only define our own callback, _**but run it too.**_

### index.js

We're creating a function `handleJsonRead` and it will receive the JavaScript object \(not a string\) as a parameter.

```javascript
import { read } from 'jsonFileStorage.js';

const handleJsonRead = (jsonContentObj) => {
  // Same code as above to calculate and log average temperature.
};

read('data.json', handleJsonRead);
```

### jsonFileStorage.js

This file deals with parsing the JSON string into a JavaScript object.

On line 1 we accept a function as an argument to the `read` function.

On line 14 **after the file is read, and the JSON is parsed**, we call the `handleJsonRead` function and pass in the JavaScript object we got from the file.

```javascript
import { readFile } from 'fs';

// read the file at `filename` and call the callback function `handleJsonRead`.
// callback `handleJsonRead` takes 1 parameter, the parsed JSON content.
export function read(filename, handleJsonRead) {
  const handleFileRead = (readErr, jsonContentStr) => {
    if (readErr) {
      console.log('Read error', readErr);
    }

    // Parse JSON content str into JS Object
    const jsonContentObj = JSON.parse(jsonContentStr);

    // Call custom logic that our app passed into this module
    handleJsonRead(jsonContentObj);
  };

  readFile(filename, 'utf-8', handleFileRead);
}
```

### Line 14 allows us to pass data back into the function in the index.js file.

This allows us to keep generic actions like `JSON.parse` in the module file code.

To understand the flow of control make sure you are following both the code in `jsonFileStorage.js` and `index.js`.

## Exercise

Try out each version of the code.

Copy the final version of this code. Add `console.log` to the beginning of each block and before and after each function call in both files to see the control flow.

