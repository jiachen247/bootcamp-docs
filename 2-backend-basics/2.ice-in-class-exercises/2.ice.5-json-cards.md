# 2.ICE.5: JSON Cards

## Introduction

We will practise reading and writing from JSON files by creating a card game that stores its game state in a local JSON file. 

## Base

1. Clone the[ base starter code](https://github.com/rocketacademy/base-node-bootcamp).
2. Create an empty JSON file `data.json` with an empty JSON object in it `{}`.
3. Copy the [hard-coded card deck array from Coding Basics](https://basics.rocketacademy.co/10-javascript-objects/10.1-javascript-objects#hard-coded-card-deck) into `index.js`.
4. Create a `jsonFileStorage.js` file in the repo with `add`, `read`, and `write` code from [Module 2.13.1](../2.13-json/2.13.1-json-file-storage-module-add-read-write.md). We will use that code in this exercise.

### Add New Shuffled Card Deck

When a user passes the `shuffle` parameter to our command line app, shuffle the deck and use the `add` function from `jsonFileStorage` to save the deck in `data.json`.

```text
node index.js shuffle
```

### Deal Cards From Deck

```text
node index.js deal
```

Read from the deck by calling the `read` function.

{% hint style="info" %}
### Why we can't just use `jsonFileStorage` as-is

The `read` function can't truly deal two cards, because it can only `console.log`. We can't leave the module intact and `read` or `pop` 2 cards from the deck, or even format the output in any way, e.g. "Queen of Spades".

We'll use `read` and `write` together and write our own card logic.

Begin the game by using [this data.json file](https://raw.githubusercontent.com/rocketacademy/bootcamp-docs/master/2-back-end-basics/2.13-json/data.json) of an unshuffled deck, and one key for the hand.

Whenever we need to change something in `data.json`, create a new function for it based on the `modifyJsonFile` function below. Write the needed logic to change the JSON data starting on line 11.

```javascript
const modifyJsonFile = (filename) => {
  // set the file read callback
  const handleFileRead = (error, jsonContent) => {
    // check for reading errors
    if (error) {
      console.log('reading error', error);
    }

    // make JSON string into an object
    const content = JSON.parse(jsonContent);
    console.log(content);

    // here is where any changes to the JSON file go

    // change the object into a string
    const stringContent = JSON.stringify(content);

    // set the file write callback
    const handleFileWrite = (error) => {
      // check for writing errors
      if (error) {
        console.log('writing error', error);
      }
    };

    // write the file
    writeFile(filename, stringContent, handleFileWrite);
  };

  // read the file
  readFile(filename, 'utf-8', handleFileRead);
};
```
{% endhint %}

## Comfortable

### Shuffle Existing Card Deck

Now, when a user provides the `shuffle` parameter to our command line app, read the existing card deck from `data.json`, shuffle it in our app, and write the shuffled version back to `data.json`. Open `data.json` to confirm that we've shuffled the cards. 

```text
node index.js shuffle
```

### Deal V2

```text
node index.js deal
```

Take 2 cards _out of the deck_ and put them in the `currentHand` key of `data.json`.

Print out the cards.

Open the `data.json` file to confirm that the top two cards have been taken out of the deck and put into the hand.

### High Card

```text
node index.js play
```

Deal 2 cards out of the deck, 1 for the computer player and 1 for the human player. The winner has the highest card.

```text
Computer got: 2 of spades.
You have: 9 of hearts.
You win!
```

## Comfortable

Incorporate Blackjack logic into the game. Evaluate the cards based on the rules of Blackjack. \(Without the logic of adding cards to the hand\). You can reuse logic from previous code.

## More Comfortable

Implement the rest of a Blackjack game \(in this order\):

1. Allow the player to hit
2. Implement the dealer behaviour. This shouldn't need a separate key in `data.json`.
3. Implement splits

